<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java学习," />










<meta name="description" content="java的设计模式资料来源：JAVA的23中设计模式 一、设计模式的分类总体来说分三大类(共二十三种)创建型模式(有五种):1.工厂方法模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 结构型模式(有七种):1.适配器模式 2.装饰器模式 3.代理模式 4.外观模式 5.桥接模式 6.组合模式 7.享元模式 行为型模式(有十一种):1.策略模式 2.模板方法模式 3.观察者模式">
<meta name="keywords" content="java学习">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA的设计模式总览">
<meta property="og:url" content="http://yoursite.com/2018/06/04/JAVA的设计模式总览/index.html">
<meta property="og:site_name" content="InnovatorZhang&#39;s blog">
<meta property="og:description" content="java的设计模式资料来源：JAVA的23中设计模式 一、设计模式的分类总体来说分三大类(共二十三种)创建型模式(有五种):1.工厂方法模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 结构型模式(有七种):1.适配器模式 2.装饰器模式 3.代理模式 4.外观模式 5.桥接模式 6.组合模式 7.享元模式 行为型模式(有十一种):1.策略模式 2.模板方法模式 3.观察者模式">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-04T13:19:51.834Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA的设计模式总览">
<meta name="twitter:description" content="java的设计模式资料来源：JAVA的23中设计模式 一、设计模式的分类总体来说分三大类(共二十三种)创建型模式(有五种):1.工厂方法模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 结构型模式(有七种):1.适配器模式 2.装饰器模式 3.代理模式 4.外观模式 5.桥接模式 6.组合模式 7.享元模式 行为型模式(有十一种):1.策略模式 2.模板方法模式 3.观察者模式">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/04/JAVA的设计模式总览/"/>





  <title>JAVA的设计模式总览 | InnovatorZhang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">InnovatorZhang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Sakura</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/JAVA的设计模式总览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZZH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InnovatorZhang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA的设计模式总览</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-04T20:57:24+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java的设计模式"><a href="#java的设计模式" class="headerlink" title="java的设计模式"></a>java的设计模式</h1><p>资料来源：<a href="https://blog.csdn.net/wenzhi20102321/article/details/54601909" target="_blank" rel="noopener">JAVA的23中设计模式</a></p>
<h2 id="一、设计模式的分类"><a href="#一、设计模式的分类" class="headerlink" title="一、设计模式的分类"></a>一、设计模式的分类</h2><h3 id="总体来说分三大类-共二十三种"><a href="#总体来说分三大类-共二十三种" class="headerlink" title="总体来说分三大类(共二十三种)"></a>总体来说分三大类(共二十三种)</h3><h4 id="创建型模式-有五种"><a href="#创建型模式-有五种" class="headerlink" title="创建型模式(有五种):"></a>创建型模式(有五种):</h4><pre><code>1.工厂方法模式
2.抽象工厂模式
3.单例模式
4.建造者模式
5.原型模式
</code></pre><h4 id="结构型模式-有七种"><a href="#结构型模式-有七种" class="headerlink" title="结构型模式(有七种):"></a>结构型模式(有七种):</h4><pre><code>1.适配器模式
2.装饰器模式
3.代理模式
4.外观模式
5.桥接模式
6.组合模式
7.享元模式
</code></pre><h4 id="行为型模式-有十一种"><a href="#行为型模式-有十一种" class="headerlink" title="行为型模式(有十一种):"></a>行为型模式(有十一种):</h4><pre><code>1.策略模式
2.模板方法模式
3.观察者模式
4.迭代子模式
5.责任链模式
6.命令模式
7.备忘录模式
8.状态模式
9.访问者模式
10.中介者模式
11.解释器模式
</code></pre><h3 id="两类特殊模式"><a href="#两类特殊模式" class="headerlink" title="两类特殊模式"></a>两类特殊模式</h3><pre><code>1.并发型模式
2.线程池模式
</code></pre><h2 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h2><h3 id="1、开闭原则-Open-Close-Principle"><a href="#1、开闭原则-Open-Close-Principle" class="headerlink" title="1、开闭原则(Open Close Principle)"></a>1、开闭原则(Open Close Principle)</h3><pre><code>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，
实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
</code></pre><h3 id="2、里氏代换原则-Liskov-Substitution-Principle"><a href="#2、里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="2、里氏代换原则(Liskov Substitution Principle)"></a>2、里氏代换原则(Liskov Substitution Principle)</h3><pre><code>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 
里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 
LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，
基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。
实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，
所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科
</code></pre><h3 id="3、依赖倒转原则-Dependence-Inversion-Principle"><a href="#3、依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="3、依赖倒转原则(Dependence Inversion Principle)"></a>3、依赖倒转原则(Dependence Inversion Principle)</h3><pre><code>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
</code></pre><h3 id="4、接口隔离原则-Interface-Segregation-Principle"><a href="#4、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="4、接口隔离原则(Interface Segregation Principle)"></a>4、接口隔离原则(Interface Segregation Principle)</h3><pre><code>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，
从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。
所以上文中多次出现：降低依赖，降低耦合。
</code></pre><h3 id="5、迪米特法则-最少知道原则-Demeter-Principle"><a href="#5、迪米特法则-最少知道原则-Demeter-Principle" class="headerlink" title="5、迪米特法则(最少知道原则)(Demeter Principle)"></a>5、迪米特法则(最少知道原则)(Demeter Principle)</h3><pre><code>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，
使得系统功能模块相对独立。
</code></pre><h3 id="6、合成复用法则-Composite-Reuse-Principle"><a href="#6、合成复用法则-Composite-Reuse-Principle" class="headerlink" title="6、合成复用法则(Composite Reuse Principle)"></a>6、合成复用法则(Composite Reuse Principle)</h3><pre><code>原则是尽量使用合成/聚合的方式，而不是使用继承。
</code></pre><h2 id="三、各种设计模式的概述"><a href="#三、各种设计模式的概述" class="headerlink" title="三、各种设计模式的概述"></a>三、各种设计模式的概述</h2><h3 id="一-工厂方法模式"><a href="#一-工厂方法模式" class="headerlink" title="(一)工厂方法模式"></a>(一)工厂方法模式</h3><h4 id="1-普通工厂模式"><a href="#1-普通工厂模式" class="headerlink" title="1.普通工厂模式"></a>1.普通工厂模式</h4><pre><code>建立一个工厂类，对实现了同一接口的一些类进行实例的创建。
</code></pre><h4 id="2-多个工厂方法模式"><a href="#2-多个工厂方法模式" class="headerlink" title="2.多个工厂方法模式"></a>2.多个工厂方法模式</h4><pre><code>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确
的创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。
</code></pre><h3 id="二-抽象工厂模式"><a href="#二-抽象工厂模式" class="headerlink" title="(二)抽象工厂模式"></a>(二)抽象工厂模式</h3><pre><code>创建多个工厂类，这样的话一旦需要增加新的功能，直接可以增加新的工厂类，不需要修改之前
的代码。
</code></pre><h3 id="三-单例模式"><a href="#三-单例模式" class="headerlink" title="(三)单例模式"></a>(三)单例模式</h3><pre><code>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，
该对象只有一个实例存在。 
</code></pre><h4 id="1-懒汉式单例"><a href="#1-懒汉式单例" class="headerlink" title="1.懒汉式单例"></a>1.懒汉式单例</h4><pre><code>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，
Singleton的唯一实例只能通过getInstance()方法访问。但是以上懒汉式单例的实现没有考虑线程
安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例。
</code></pre><h4 id="2-饿汉式单例"><a href="#2-饿汉式单例" class="headerlink" title="2.饿汉式单例"></a>2.饿汉式单例</h4><pre><code>饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。
</code></pre><h4 id="3-登记式单例"><a href="#3-登记式单例" class="headerlink" title="3.登记式单例"></a>3.登记式单例</h4><pre><code>实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实
例，则从Map直接返回，对于没有登记的，则先登记，然后返回。这个用得最少。
</code></pre><h3 id="四-建造者模式-Builder"><a href="#四-建造者模式-Builder" class="headerlink" title="(四)建造者模式(Builder)"></a>(四)建造者模式(Builder)</h3><pre><code>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，
用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。
</code></pre><h3 id="五-原型模式-Prototype"><a href="#五-原型模式-Prototype" class="headerlink" title="(五)原型模式(Prototype)"></a>(五)原型模式(Prototype)</h3><pre><code>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将
一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
</code></pre><h3 id="六-适配器模式-Adapter"><a href="#六-适配器模式-Adapter" class="headerlink" title="(六)适配器模式(Adapter)"></a>(六)适配器模式(Adapter)</h3><pre><code>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造
成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
</code></pre><h3 id="七-装饰模式-Decorator"><a href="#七-装饰模式-Decorator" class="headerlink" title="(七)装饰模式(Decorator)"></a>(七)装饰模式(Decorator)</h3><pre><code>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一
个接口，装饰对象持有被装饰对象的实例。
</code></pre><h3 id="八-代理模式-Proxy"><a href="#八-代理模式-Proxy" class="headerlink" title="(八)代理模式(Proxy)"></a>(八)代理模式(Proxy)</h3><pre><code>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候会去找中介，
为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的
代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可
以替我们进行操作，表达我们的想法
</code></pre><h3 id="九-外观模式-Facade"><a href="#九-外观模式-Facade" class="headerlink" title="(九)外观模式(Facade)"></a>(九)外观模式(Facade)</h3><pre><code>外观模式是为了解决类与类之家的依赖关系的，可以将类和类之间的关系配置到配置文件中，而外
观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接
口。
</code></pre><h3 id="十-桥接模式-Bridge"><a href="#十-桥接模式-Bridge" class="headerlink" title="(十)桥接模式(Bridge)"></a>(十)桥接模式(Bridge)</h3><pre><code>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与
实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数
据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是
JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。
</code></pre><h3 id="十一-组合模式-Composite"><a href="#十一-组合模式-Composite" class="headerlink" title="(十一)组合模式(Composite)"></a>(十一)组合模式(Composite)</h3><pre><code>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便
</code></pre><h3 id="十二-享元模式-Flyweight"><a href="#十二-享元模式-Flyweight" class="headerlink" title="(十二)享元模式(Flyweight)"></a>(十二)享元模式(Flyweight)</h3><pre><code>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，
通常与工厂模式一起使用。
</code></pre><h3 id="十三-策略模式-Strategy"><a href="#十三-策略模式-Strategy" class="headerlink" title="(十三)策略模式(Strategy)"></a>(十三)策略模式(Strategy)</h3><pre><code>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影
响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接
口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。
</code></pre><h3 id="十四-模板方法模式-Template-Method"><a href="#十四-模板方法模式-Template-Method" class="headerlink" title="(十四)模板方法模式(Template Method)"></a>(十四)模板方法模式(Template Method)</h3><pre><code>模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可
以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调
用。
</code></pre><h3 id="十五-观察者模式-Observer"><a href="#十五-观察者模式-Observer" class="headerlink" title="(十五)观察者模式(Observer)"></a>(十五)观察者模式(Observer)</h3><pre><code>观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS
图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一
句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种
一对多的关系。
</code></pre><h3 id="十六-迭代子模式-Iterator"><a href="#十六-迭代子模式-Iterator" class="headerlink" title="(十六)迭代子模式(Iterator)"></a>(十六)迭代子模式(Iterator)</h3><pre><code>迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话
，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器
对象，用于对聚集对象进行遍历访问。
</code></pre><h3 id="十七-责任链模式-Chain-of-Responsibility"><a href="#十七-责任链模式-Chain-of-Responsibility" class="headerlink" title="(十七)责任链模式(Chain of Responsibility)"></a>(十七)责任链模式(Chain of Responsibility)</h3><pre><code>责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条
链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，
所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
</code></pre><h3 id="十八-命令模式-Command"><a href="#十八-命令模式-Command" class="headerlink" title="(十八)命令模式(Command)"></a>(十八)命令模式(Command)</h3><pre><code>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员
的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互
解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关
注到底士兵是怎么实现的。
</code></pre><h3 id="十九-备忘录模式-Memento"><a href="#十九-备忘录模式-Memento" class="headerlink" title="(十九)备忘录模式(Memento)"></a>(十九)备忘录模式(Memento)</h3><pre><code>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些
，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存
储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。
</code></pre><h3 id="二十-状态模式-State"><a href="#二十-状态模式-State" class="headerlink" title="(二十)状态模式(State)"></a>(二十)状态模式(State)</h3><pre><code>当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌
等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可
以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。
</code></pre><h3 id="二十一-访问者模式-Visitor"><a href="#二十一-访问者模式-Visitor" class="headerlink" title="(二十一)访问者模式(Visitor)"></a>(二十一)访问者模式(Visitor)</h3><pre><code>访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态
添加新的操作而无需做其它的修改的效果。
</code></pre><h3 id="二十二-中介者模式-Mediator"><a href="#二十二-中介者模式-Mediator" class="headerlink" title="(二十二)中介者模式(Mediator)"></a>(二十二)中介者模式(Mediator)</h3><pre><code>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓
展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关
心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行。
</code></pre><h3 id="二十三-解释器模式-Interpreter"><a href="#二十三-解释器模式-Interpreter" class="headerlink" title="(二十三)解释器模式(Interpreter)"></a>(二十三)解释器模式(Interpreter)</h3><pre><code>解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上是看的别人的blog，后面慢慢研究设计模式</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java学习/" rel="tag"># java学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/04/apt-get-dpkg命令的用法/" rel="next" title="apt-get dpkg命令的用法">
                <i class="fa fa-chevron-left"></i> apt-get dpkg命令的用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ZZH</p>
              <p class="site-description motion-element" itemprop="description">希望能将学习的知识写在这上面</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java的设计模式"><span class="nav-number">1.</span> <span class="nav-text">java的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、设计模式的分类"><span class="nav-number">1.1.</span> <span class="nav-text">一、设计模式的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总体来说分三大类-共二十三种"><span class="nav-number">1.1.1.</span> <span class="nav-text">总体来说分三大类(共二十三种)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建型模式-有五种"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">创建型模式(有五种):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构型模式-有七种"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">结构型模式(有七种):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行为型模式-有十一种"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">行为型模式(有十一种):</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两类特殊模式"><span class="nav-number">1.1.2.</span> <span class="nav-text">两类特殊模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、设计模式的六大原则"><span class="nav-number">1.2.</span> <span class="nav-text">二、设计模式的六大原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、开闭原则-Open-Close-Principle"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、开闭原则(Open Close Principle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、里氏代换原则-Liskov-Substitution-Principle"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、里氏代换原则(Liskov Substitution Principle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、依赖倒转原则-Dependence-Inversion-Principle"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、依赖倒转原则(Dependence Inversion Principle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、接口隔离原则-Interface-Segregation-Principle"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、接口隔离原则(Interface Segregation Principle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、迪米特法则-最少知道原则-Demeter-Principle"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、迪米特法则(最少知道原则)(Demeter Principle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、合成复用法则-Composite-Reuse-Principle"><span class="nav-number">1.2.6.</span> <span class="nav-text">6、合成复用法则(Composite Reuse Principle)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、各种设计模式的概述"><span class="nav-number">1.3.</span> <span class="nav-text">三、各种设计模式的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-工厂方法模式"><span class="nav-number">1.3.1.</span> <span class="nav-text">(一)工厂方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-普通工厂模式"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.普通工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-多个工厂方法模式"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2.多个工厂方法模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-抽象工厂模式"><span class="nav-number">1.3.2.</span> <span class="nav-text">(二)抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-单例模式"><span class="nav-number">1.3.3.</span> <span class="nav-text">(三)单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-懒汉式单例"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1.懒汉式单例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-饿汉式单例"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2.饿汉式单例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-登记式单例"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.登记式单例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-建造者模式-Builder"><span class="nav-number">1.3.4.</span> <span class="nav-text">(四)建造者模式(Builder)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-原型模式-Prototype"><span class="nav-number">1.3.5.</span> <span class="nav-text">(五)原型模式(Prototype)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-适配器模式-Adapter"><span class="nav-number">1.3.6.</span> <span class="nav-text">(六)适配器模式(Adapter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-装饰模式-Decorator"><span class="nav-number">1.3.7.</span> <span class="nav-text">(七)装饰模式(Decorator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-代理模式-Proxy"><span class="nav-number">1.3.8.</span> <span class="nav-text">(八)代理模式(Proxy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-外观模式-Facade"><span class="nav-number">1.3.9.</span> <span class="nav-text">(九)外观模式(Facade)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-桥接模式-Bridge"><span class="nav-number">1.3.10.</span> <span class="nav-text">(十)桥接模式(Bridge)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一-组合模式-Composite"><span class="nav-number">1.3.11.</span> <span class="nav-text">(十一)组合模式(Composite)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十二-享元模式-Flyweight"><span class="nav-number">1.3.12.</span> <span class="nav-text">(十二)享元模式(Flyweight)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十三-策略模式-Strategy"><span class="nav-number">1.3.13.</span> <span class="nav-text">(十三)策略模式(Strategy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十四-模板方法模式-Template-Method"><span class="nav-number">1.3.14.</span> <span class="nav-text">(十四)模板方法模式(Template Method)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十五-观察者模式-Observer"><span class="nav-number">1.3.15.</span> <span class="nav-text">(十五)观察者模式(Observer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十六-迭代子模式-Iterator"><span class="nav-number">1.3.16.</span> <span class="nav-text">(十六)迭代子模式(Iterator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十七-责任链模式-Chain-of-Responsibility"><span class="nav-number">1.3.17.</span> <span class="nav-text">(十七)责任链模式(Chain of Responsibility)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十八-命令模式-Command"><span class="nav-number">1.3.18.</span> <span class="nav-text">(十八)命令模式(Command)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十九-备忘录模式-Memento"><span class="nav-number">1.3.19.</span> <span class="nav-text">(十九)备忘录模式(Memento)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十-状态模式-State"><span class="nav-number">1.3.20.</span> <span class="nav-text">(二十)状态模式(State)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十一-访问者模式-Visitor"><span class="nav-number">1.3.21.</span> <span class="nav-text">(二十一)访问者模式(Visitor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十二-中介者模式-Mediator"><span class="nav-number">1.3.22.</span> <span class="nav-text">(二十二)中介者模式(Mediator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十三-解释器模式-Interpreter"><span class="nav-number">1.3.23.</span> <span class="nav-text">(二十三)解释器模式(Interpreter)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZZH</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
